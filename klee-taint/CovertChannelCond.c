// RUN: %llvmgcc %s -emit-llvm -g -O0 -c -o %t.bc
// RUN: rm -rf %t.klee-out
// RUN: %klee -taint=controlflow --output-dir=%t.klee-out -exit-on-error %t.bc


/*ERROR: This works as a covert channel (The idea is that it wont)*/
#include<klee/klee.h>

#define CASE(x) case x: return x; break

char  covert_channel(unsigned char c){
  int i;
  printf("covertchannel of byte %d with taint %x\n",c, klee_get_taint(&c,1));
  switch(c){
  CASE(0x00);CASE(0x01);CASE(0x02);CASE(0x03);CASE(0x04);CASE(0x05);CASE(0x06);CASE(0x07);CASE(0x08);CASE(0x09);CASE(0x0a);CASE(0x0b);CASE(0x0c);CASE(0x0d);CASE(0x0e);CASE(0x0f);CASE(0x10);CASE(0x11);CASE(0x12);CASE(0x13);CASE(0x14);CASE(0x15);CASE(0x16);CASE(0x17);CASE(0x18);CASE(0x19);CASE(0x1a);CASE(0x1b);CASE(0x1c);CASE(0x1d);CASE(0x1e);CASE(0x1f);CASE(0x20);CASE(0x21);CASE(0x22);CASE(0x23);CASE(0x24);CASE(0x25);CASE(0x26);CASE(0x27);CASE(0x28);CASE(0x29);CASE(0x2a);CASE(0x2b);CASE(0x2c);CASE(0x2d);CASE(0x2e);CASE(0x2f);CASE(0x30);CASE(0x31);CASE(0x32);CASE(0x33);CASE(0x34);CASE(0x35);CASE(0x36);CASE(0x37);CASE(0x38);CASE(0x39);CASE(0x3a);CASE(0x3b);CASE(0x3c);CASE(0x3d);CASE(0x3e);CASE(0x3f);CASE(0x40);CASE(0x41);CASE(0x42);CASE(0x43);CASE(0x44);CASE(0x45);CASE(0x46);CASE(0x47);CASE(0x48);CASE(0x49);CASE(0x4a);CASE(0x4b);CASE(0x4c);CASE(0x4d);CASE(0x4e);CASE(0x4f);CASE(0x50);CASE(0x51);CASE(0x52);CASE(0x53);CASE(0x54);CASE(0x55);CASE(0x56);CASE(0x57);CASE(0x58);CASE(0x59);CASE(0x5a);CASE(0x5b);CASE(0x5c);CASE(0x5d);CASE(0x5e);CASE(0x5f);CASE(0x60);CASE(0x61);CASE(0x62);CASE(0x63);CASE(0x64);CASE(0x65);CASE(0x66);CASE(0x67);CASE(0x68);CASE(0x69);CASE(0x6a);CASE(0x6b);CASE(0x6c);CASE(0x6d);CASE(0x6e);CASE(0x6f);CASE(0x70);CASE(0x71);CASE(0x72);CASE(0x73);CASE(0x74);CASE(0x75);CASE(0x76);CASE(0x77);CASE(0x78);CASE(0x79);CASE(0x7a);CASE(0x7b);CASE(0x7c);CASE(0x7d);CASE(0x7e);CASE(0x7f);CASE(0x80);CASE(0x81);CASE(0x82);CASE(0x83);CASE(0x84);CASE(0x85);CASE(0x86);CASE(0x87);CASE(0x88);CASE(0x89);CASE(0x8a);CASE(0x8b);CASE(0x8c);CASE(0x8d);CASE(0x8e);CASE(0x8f);CASE(0x90);CASE(0x91);CASE(0x92);CASE(0x93);CASE(0x94);CASE(0x95);CASE(0x96);CASE(0x97);CASE(0x98);CASE(0x99);CASE(0x9a);CASE(0x9b);CASE(0x9c);CASE(0x9d);CASE(0x9e);CASE(0x9f);CASE(0xa0);CASE(0xa1);CASE(0xa2);CASE(0xa3);CASE(0xa4);CASE(0xa5);CASE(0xa6);CASE(0xa7);CASE(0xa8);CASE(0xa9);CASE(0xaa);CASE(0xab);CASE(0xac);CASE(0xad);CASE(0xae);CASE(0xaf);CASE(0xb0);CASE(0xb1);CASE(0xb2);CASE(0xb3);CASE(0xb4);CASE(0xb5);CASE(0xb6);CASE(0xb7);CASE(0xb8);CASE(0xb9);CASE(0xba);CASE(0xbb);CASE(0xbc);CASE(0xbd);CASE(0xbe);CASE(0xbf);CASE(0xc0);CASE(0xc1);CASE(0xc2);CASE(0xc3);CASE(0xc4);CASE(0xc5);CASE(0xc6);CASE(0xc7);CASE(0xc8);CASE(0xc9);CASE(0xca);CASE(0xcb);CASE(0xcc);CASE(0xcd);CASE(0xce);CASE(0xcf);CASE(0xd0);CASE(0xd1);CASE(0xd2);CASE(0xd3);CASE(0xd4);CASE(0xd5);CASE(0xd6);CASE(0xd7);CASE(0xd8);CASE(0xd9);CASE(0xda);CASE(0xdb);CASE(0xdc);CASE(0xdd);CASE(0xde);CASE(0xdf);CASE(0xe0);CASE(0xe1);CASE(0xe2);CASE(0xe3);CASE(0xe4);CASE(0xe5);CASE(0xe6);CASE(0xe7);CASE(0xe8);CASE(0xe9);CASE(0xea);CASE(0xeb);CASE(0xec);CASE(0xed);CASE(0xee);CASE(0xef);CASE(0xf0);CASE(0xf1);CASE(0xf2);CASE(0xf3);CASE(0xf4);CASE(0xf5);CASE(0xf6);CASE(0xf7);CASE(0xf8);CASE(0xf9);CASE(0xfa);CASE(0xfb);CASE(0xfc);CASE(0xfd);CASE(0xfe);CASE(0xff);
  }
  return 0xff;
}

int
main (int argc, char *argv[])
{
  int i=0;
  char input[7]="SECRET";
  char output[7];


  klee_set_taint(0x8, output, 7);
  klee_set_taint(0x1, input, 7);

  for (i=0; i<7; i++)
    output[i] = covert_channel(input[i]);

  klee_assert(klee_get_taint(output, sizeof(output))==(0x1));

}
