        -:    0:Source:../../src/system.h
        -:    0:Graph:echo.gcno
        -:    0:Data:echo.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* system-dependent definitions for coreutils
        -:    2:   Copyright (C) 1989, 1991-2008 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:#include <alloca.h>
        -:   18:
        -:   19:/* Include sys/types.h before this file.  */
        -:   20:
        -:   21:#if 2 <= __GLIBC__ && 2 <= __GLIBC_MINOR__
        -:   22:# if ! defined _SYS_TYPES_H
        -:   23:you must include <sys/types.h> before including this file
        -:   24:# endif
        -:   25:#endif
        -:   26:
        -:   27:#include <sys/stat.h>
        -:   28:
        -:   29:#if !defined HAVE_MKFIFO
        -:   30:# define mkfifo(name, mode) mknod (name, (mode) | S_IFIFO, 0)
        -:   31:#endif
        -:   32:
        -:   33:#if HAVE_SYS_PARAM_H
        -:   34:# include <sys/param.h>
        -:   35:#endif
        -:   36:
        -:   37:#include <unistd.h>
        -:   38:
        -:   39:#ifndef STDIN_FILENO
        -:   40:# define STDIN_FILENO 0
        -:   41:#endif
        -:   42:
        -:   43:#ifndef STDOUT_FILENO
        -:   44:# define STDOUT_FILENO 1
        -:   45:#endif
        -:   46:
        -:   47:#ifndef STDERR_FILENO
        -:   48:# define STDERR_FILENO 2
        -:   49:#endif
        -:   50:
        -:   51:
        -:   52:/* limits.h must come before pathmax.h because limits.h on some systems
        -:   53:   undefs PATH_MAX, whereas pathmax.h sets PATH_MAX.  */
        -:   54:#include <limits.h>
        -:   55:
        -:   56:#include "pathmax.h"
        -:   57:
        -:   58:#include "configmake.h"
        -:   59:
        -:   60:#if TIME_WITH_SYS_TIME
        -:   61:# include <sys/time.h>
        -:   62:# include <time.h>
        -:   63:#else
        -:   64:# if HAVE_SYS_TIME_H
        -:   65:#  include <sys/time.h>
        -:   66:# else
        -:   67:#  include <time.h>
        -:   68:# endif
        -:   69:#endif
        -:   70:
        -:   71:/* Since major is a function on SVR4, we can't use `ifndef major'.  */
        -:   72:#if MAJOR_IN_MKDEV
        -:   73:# include <sys/mkdev.h>
        -:   74:# define HAVE_MAJOR
        -:   75:#endif
        -:   76:#if MAJOR_IN_SYSMACROS
        -:   77:# include <sys/sysmacros.h>
        -:   78:# define HAVE_MAJOR
        -:   79:#endif
        -:   80:#ifdef major			/* Might be defined in sys/types.h.  */
        -:   81:# define HAVE_MAJOR
        -:   82:#endif
        -:   83:
        -:   84:#ifndef HAVE_MAJOR
        -:   85:# define major(dev)  (((dev) >> 8) & 0xff)
        -:   86:# define minor(dev)  ((dev) & 0xff)
        -:   87:# define makedev(maj, min)  (((maj) << 8) | (min))
        -:   88:#endif
        -:   89:#undef HAVE_MAJOR
        -:   90:
        -:   91:#if ! defined makedev && defined mkdev
        -:   92:# define makedev(maj, min)  mkdev (maj, min)
        -:   93:#endif
        -:   94:
        -:   95:/* Don't use bcopy!  Use memmove if source and destination may overlap,
        -:   96:   memcpy otherwise.  */
        -:   97:
        -:   98:#include <string.h>
        -:   99:
        -:  100:#include <errno.h>
        -:  101:
        -:  102:/* Some systems don't define the following symbols.  */
        -:  103:#ifndef EDQUOT
        -:  104:# define EDQUOT (-1)
        -:  105:#endif
        -:  106:#ifndef EISDIR
        -:  107:# define EISDIR (-1)
        -:  108:#endif
        -:  109:#ifndef ENOSYS
        -:  110:# define ENOSYS (-1)
        -:  111:#endif
        -:  112:#ifndef ENODATA
        -:  113:# define ENODATA (-1)
        -:  114:#endif
        -:  115:
        -:  116:#include <stdbool.h>
        -:  117:#include <stdlib.h>
        -:  118:
        -:  119:/* Exit statuses for programs like 'env' that exec other programs.  */
        -:  120:enum
        -:  121:{
        -:  122:  EXIT_CANNOT_INVOKE = 126,
        -:  123:  EXIT_ENOENT = 127
        -:  124:};
        -:  125:
        -:  126:#include "exitfail.h"
        -:  127:
        -:  128:/* Set exit_failure to STATUS if that's not the default already.  */
        -:  129:static inline void
        -:  130:initialize_exit_failure (int status)
        -:  131:{
        -:  132:  if (status != EXIT_FAILURE)
        -:  133:    exit_failure = status;
        -:  134:}
        -:  135:
        -:  136:#include <fcntl.h>
        -:  137:
        -:  138:#ifndef F_OK
        -:  139:# define F_OK 0
        -:  140:# define X_OK 1
        -:  141:# define W_OK 2
        -:  142:# define R_OK 4
        -:  143:#endif
        -:  144:
        -:  145:#include <dirent.h>
        -:  146:#ifndef _D_EXACT_NAMLEN
        -:  147:# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
        -:  148:#endif
        -:  149:
        -:  150:enum
        -:  151:{
        -:  152:  NOT_AN_INODE_NUMBER = 0
        -:  153:};
        -:  154:
        -:  155:#ifdef D_INO_IN_DIRENT
        -:  156:# define D_INO(dp) (dp)->d_ino
        -:  157:#else
        -:  158:/* Some systems don't have inodes, so fake them to avoid lots of ifdefs.  */
        -:  159:# define D_INO(dp) NOT_AN_INODE_NUMBER
        -:  160:#endif
        -:  161:
        -:  162:/* Get or fake the disk device blocksize.
        -:  163:   Usually defined by sys/param.h (if at all).  */
        -:  164:#if !defined DEV_BSIZE && defined BSIZE
        -:  165:# define DEV_BSIZE BSIZE
        -:  166:#endif
        -:  167:#if !defined DEV_BSIZE && defined BBSIZE /* SGI */
        -:  168:# define DEV_BSIZE BBSIZE
        -:  169:#endif
        -:  170:#ifndef DEV_BSIZE
        -:  171:# define DEV_BSIZE 4096
        -:  172:#endif
        -:  173:
        -:  174:/* Extract or fake data from a `struct stat'.
        -:  175:   ST_BLKSIZE: Preferred I/O blocksize for the file, in bytes.
        -:  176:   ST_NBLOCKS: Number of blocks in the file, including indirect blocks.
        -:  177:   ST_NBLOCKSIZE: Size of blocks used when calculating ST_NBLOCKS.  */
        -:  178:#ifndef HAVE_STRUCT_STAT_ST_BLOCKS
        -:  179:# define ST_BLKSIZE(statbuf) DEV_BSIZE
        -:  180:# if defined _POSIX_SOURCE || !defined BSIZE /* fileblocks.c uses BSIZE.  */
        -:  181:#  define ST_NBLOCKS(statbuf) \
        -:  182:  ((statbuf).st_size / ST_NBLOCKSIZE + ((statbuf).st_size % ST_NBLOCKSIZE != 0))
        -:  183:# else /* !_POSIX_SOURCE && BSIZE */
        -:  184:#  define ST_NBLOCKS(statbuf) \
        -:  185:  (S_ISREG ((statbuf).st_mode) \
        -:  186:   || S_ISDIR ((statbuf).st_mode) \
        -:  187:   ? st_blocks ((statbuf).st_size) : 0)
        -:  188:# endif /* !_POSIX_SOURCE && BSIZE */
        -:  189:#else /* HAVE_STRUCT_STAT_ST_BLOCKS */
        -:  190:/* Some systems, like Sequents, return st_blksize of 0 on pipes.
        -:  191:   Also, when running `rsh hpux11-system cat any-file', cat would
        -:  192:   determine that the output stream had an st_blksize of 2147421096.
        -:  193:   Conversely st_blksize can be 2 GiB (or maybe even larger) with XFS
        -:  194:   on 64-bit hosts.  Somewhat arbitrarily, limit the `optimal' block
        -:  195:   size to SIZE_MAX / 8 + 1.  (Dividing SIZE_MAX by only 4 wouldn't
        -:  196:   suffice, since "cat" sometimes multiplies the result by 4.)  If
        -:  197:   anyone knows of a system for which this limit is too small, please
        -:  198:   report it as a bug in this code.  */
        -:  199:# define ST_BLKSIZE(statbuf) ((0 < (statbuf).st_blksize \
        -:  200:			       && (statbuf).st_blksize <= SIZE_MAX / 8 + 1) \
        -:  201:			      ? (statbuf).st_blksize : DEV_BSIZE)
        -:  202:# if defined hpux || defined __hpux__ || defined __hpux
        -:  203:/* HP-UX counts st_blocks in 1024-byte units.
        -:  204:   This loses when mixing HP-UX and BSD file systems with NFS.  */
        -:  205:#  define ST_NBLOCKSIZE 1024
        -:  206:# else /* !hpux */
        -:  207:#  if defined _AIX && defined _I386
        -:  208:/* AIX PS/2 counts st_blocks in 4K units.  */
        -:  209:#   define ST_NBLOCKSIZE (4 * 1024)
        -:  210:#  else /* not AIX PS/2 */
        -:  211:#   if defined _CRAY
        -:  212:#    define ST_NBLOCKS(statbuf) \
        -:  213:  (S_ISREG ((statbuf).st_mode) \
        -:  214:   || S_ISDIR ((statbuf).st_mode) \
        -:  215:   ? (statbuf).st_blocks * ST_BLKSIZE(statbuf)/ST_NBLOCKSIZE : 0)
        -:  216:#   endif /* _CRAY */
        -:  217:#  endif /* not AIX PS/2 */
        -:  218:# endif /* !hpux */
        -:  219:#endif /* HAVE_STRUCT_STAT_ST_BLOCKS */
        -:  220:
        -:  221:#ifndef ST_NBLOCKS
        -:  222:# define ST_NBLOCKS(statbuf) ((statbuf).st_blocks)
        -:  223:#endif
        -:  224:
        -:  225:#ifndef ST_NBLOCKSIZE
        -:  226:# ifdef S_BLKSIZE
        -:  227:#  define ST_NBLOCKSIZE S_BLKSIZE
        -:  228:# else
        -:  229:#  define ST_NBLOCKSIZE 512
        -:  230:# endif
        -:  231:#endif
        -:  232:
        -:  233:/* Redirection and wildcarding when done by the utility itself.
        -:  234:   Generally a noop, but used in particular for native VMS. */
        -:  235:#ifndef initialize_main
        -:  236:# define initialize_main(ac, av)
        -:  237:#endif
        -:  238:
        -:  239:#include "stat-macros.h"
        -:  240:
        -:  241:#include "timespec.h"
        -:  242:
        -:  243:#include <inttypes.h>
        -:  244:
        -:  245:#include <ctype.h>
        -:  246:
        -:  247:#if ! (defined isblank || HAVE_DECL_ISBLANK)
        -:  248:# define isblank(c) ((c) == ' ' || (c) == '\t')
        -:  249:#endif
        -:  250:
        -:  251:/* ISDIGIT differs from isdigit, as follows:
        -:  252:   - Its arg may be any int or unsigned int; it need not be an unsigned char
        -:  253:     or EOF.
        -:  254:   - It's typically faster.
        -:  255:   POSIX says that only '0' through '9' are digits.  Prefer ISDIGIT to
        -:  256:   isdigit unless it's important to use the locale's definition
        -:  257:   of `digit' even when the host does not conform to POSIX.  */
        -:  258:#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
        -:  259:
        -:  260:/* Convert a possibly-signed character to an unsigned character.  This is
        -:  261:   a bit safer than casting to unsigned char, since it catches some type
        -:  262:   errors that the cast doesn't.  */
        -:  263:static inline unsigned char to_uchar (char ch) { return ch; }
        -:  264:
        -:  265:#include <locale.h>
        -:  266:
        -:  267:/* Take care of NLS matters.  */
        -:  268:
        -:  269:#include "gettext.h"
        -:  270:#if ! ENABLE_NLS
        -:  271:# undef textdomain
        -:  272:# define textdomain(Domainname) /* empty */
        -:  273:# undef bindtextdomain
        -:  274:# define bindtextdomain(Domainname, Dirname) /* empty */
        -:  275:#endif
        -:  276:
        -:  277:#define _(msgid) gettext (msgid)
        -:  278:#define N_(msgid) msgid
        -:  279:
        -:  280:/* Return a value that pluralizes the same way that N does, in all
        -:  281:   languages we know of.  */
        -:  282:static inline unsigned long int
        -:  283:select_plural (uintmax_t n)
        -:  284:{
        -:  285:  /* Reduce by a power of ten, but keep it away from zero.  The
        -:  286:     gettext manual says 1000000 should be safe.  */
        -:  287:  enum { PLURAL_REDUCER = 1000000 };
        -:  288:  return (n <= ULONG_MAX ? n : n % PLURAL_REDUCER + PLURAL_REDUCER);
        -:  289:}
        -:  290:
        -:  291:#define STREQ(a, b) (strcmp (a, b) == 0)
        -:  292:
        -:  293:#if !HAVE_DECL_FREE
        -:  294:void free ();
        -:  295:#endif
        -:  296:
        -:  297:#if !HAVE_DECL_MALLOC
        -:  298:char *malloc ();
        -:  299:#endif
        -:  300:
        -:  301:#if !HAVE_DECL_MEMCHR
        -:  302:char *memchr ();
        -:  303:#endif
        -:  304:
        -:  305:#if !HAVE_DECL_REALLOC
        -:  306:char *realloc ();
        -:  307:#endif
        -:  308:
        -:  309:#if !HAVE_DECL_GETENV
        -:  310:char *getenv ();
        -:  311:#endif
        -:  312:
        -:  313:#if !HAVE_DECL_LSEEK
        -:  314:off_t lseek ();
        -:  315:#endif
        -:  316:
        -:  317:#if !HAVE_DECL_GETLOGIN
        -:  318:char *getlogin ();
        -:  319:#endif
        -:  320:
        -:  321:#if !HAVE_DECL_TTYNAME
        -:  322:char *ttyname ();
        -:  323:#endif
        -:  324:
        -:  325:#if !HAVE_DECL_GETEUID
        -:  326:uid_t geteuid ();
        -:  327:#endif
        -:  328:
        -:  329:#if !HAVE_DECL_GETPWUID
        -:  330:struct passwd *getpwuid ();
        -:  331:#endif
        -:  332:
        -:  333:#if !HAVE_DECL_GETGRGID
        -:  334:struct group *getgrgid ();
        -:  335:#endif
        -:  336:
        -:  337:#if !HAVE_DECL_GETUID
        -:  338:uid_t getuid ();
        -:  339:#endif
        -:  340:
        -:  341:#include "xalloc.h"
        -:  342:#include "verify.h"
        -:  343:
        -:  344:/* This is simply a shorthand for the common case in which
        -:  345:   the third argument to x2nrealloc would be `sizeof *(P)'.
        -:  346:   Ensure that sizeof *(P) is *not* 1.  In that case, it'd be
        -:  347:   better to use X2REALLOC, although not strictly necessary.  */
        -:  348:#define X2NREALLOC(P, PN) ((void) verify_true (sizeof *(P) != 1), \
        -:  349:			   x2nrealloc (P, PN, sizeof *(P)))
        -:  350:
        -:  351:/* Using x2realloc (when appropriate) usually makes your code more
        -:  352:   readable than using x2nrealloc, but it also makes it so your
        -:  353:   code will malfunction if sizeof *(P) ever becomes 2 or greater.
        -:  354:   So use this macro instead of using x2realloc directly.  */
        -:  355:#define X2REALLOC(P, PN) ((void) verify_true (sizeof *(P) == 1), \
        -:  356:                          x2realloc (P, PN))
        -:  357:
        -:  358:#include "unlocked-io.h"
        -:  359:#include "same-inode.h"
        -:  360:
        -:  361:#include "dirname.h"
        -:  362:#include "openat.h"
        -:  363:
        -:  364:static inline bool
        -:  365:dot_or_dotdot (char const *file_name)
        -:  366:{
        -:  367:  if (file_name[0] == '.')
        -:  368:    {
        -:  369:      char sep = file_name[(file_name[1] == '.') + 1];
        -:  370:      return (! sep || ISSLASH (sep));
        -:  371:    }
        -:  372:  else
        -:  373:    return false;
        -:  374:}
        -:  375:
        -:  376:/* A wrapper for readdir so that callers don't see entries for `.' or `..'.  */
        -:  377:static inline struct dirent const *
        -:  378:readdir_ignoring_dot_and_dotdot (DIR *dirp)
        -:  379:{
        -:  380:  while (1)
        -:  381:    {
        -:  382:      struct dirent const *dp = readdir (dirp);
        -:  383:      if (dp == NULL || ! dot_or_dotdot (dp->d_name))
        -:  384:	return dp;
        -:  385:    }
        -:  386:}
        -:  387:
        -:  388:/* Return true if DIR is determined to be an empty directory.  */
        -:  389:static inline bool
        -:  390:is_empty_dir (int fd_cwd, char const *dir)
        -:  391:{
        -:  392:  DIR *dirp;
        -:  393:  struct dirent const *dp;
        -:  394:  int saved_errno;
        -:  395:  int fd = openat (fd_cwd, dir,
        -:  396:		   (O_RDONLY | O_DIRECTORY
        -:  397:		    | O_NOCTTY | O_NOFOLLOW | O_NONBLOCK));
        -:  398:
        -:  399:  if (fd < 0)
        -:  400:    return false;
        -:  401:
        -:  402:  dirp = fdopendir (fd);
        -:  403:  if (dirp == NULL)
        -:  404:    {
        -:  405:      close (fd);
        -:  406:      return false;
        -:  407:    }
        -:  408:
        -:  409:  errno = 0;
        -:  410:  dp = readdir_ignoring_dot_and_dotdot (dirp);
        -:  411:  saved_errno = errno;
        -:  412:  closedir (dirp);
        -:  413:  if (dp != NULL)
        -:  414:    return false;
        -:  415:  return saved_errno == 0 ? true : false;
        -:  416:}
        -:  417:
        -:  418:/* Factor out some of the common --help and --version processing code.  */
        -:  419:
        -:  420:/* These enum values cannot possibly conflict with the option values
        -:  421:   ordinarily used by commands, including CHAR_MAX + 1, etc.  Avoid
        -:  422:   CHAR_MIN - 1, as it may equal -1, the getopt end-of-options value.  */
        -:  423:enum
        -:  424:{
        -:  425:  GETOPT_HELP_CHAR = (CHAR_MIN - 2),
        -:  426:  GETOPT_VERSION_CHAR = (CHAR_MIN - 3)
        -:  427:};
        -:  428:
        -:  429:#define GETOPT_HELP_OPTION_DECL \
        -:  430:  "help", no_argument, NULL, GETOPT_HELP_CHAR
        -:  431:#define GETOPT_VERSION_OPTION_DECL \
        -:  432:  "version", no_argument, NULL, GETOPT_VERSION_CHAR
        -:  433:#define GETOPT_SELINUX_CONTEXT_OPTION_DECL \
        -:  434:  "context", required_argument, NULL, 'Z'
        -:  435:
        -:  436:#define case_GETOPT_HELP_CHAR			\
        -:  437:  case GETOPT_HELP_CHAR:			\
        -:  438:    usage (EXIT_SUCCESS);			\
        -:  439:    break;
        -:  440:
        -:  441:/* Program_name must be a literal string.
        -:  442:   Usually it is just PROGRAM_NAME.  */
        -:  443:#define USAGE_BUILTIN_WARNING \
        -:  444:  _("\n" \
        -:  445:"NOTE: your shell may have its own version of %s, which usually supersedes\n" \
        -:  446:"the version described here.  Please refer to your shell's documentation\n" \
        -:  447:"for details about the options it supports.\n")
        -:  448:
        -:  449:#define HELP_OPTION_DESCRIPTION \
        -:  450:  _("      --help     display this help and exit\n")
        -:  451:#define VERSION_OPTION_DESCRIPTION \
        -:  452:  _("      --version  output version information and exit\n")
        -:  453:
        -:  454:#include "closein.h"
        -:  455:#include "closeout.h"
        -:  456:#include "version-etc.h"
        -:  457:
        -:  458:#define case_GETOPT_VERSION_CHAR(Program_name, Authors)			\
        -:  459:  case GETOPT_VERSION_CHAR:						\
        -:  460:    version_etc (stdout, Program_name, PACKAGE_NAME, VERSION, Authors,	\
        -:  461:                 (char *) NULL);					\
        -:  462:    exit (EXIT_SUCCESS);						\
        -:  463:    break;
        -:  464:
        -:  465:#ifndef MAX
        -:  466:# define MAX(a, b) ((a) > (b) ? (a) : (b))
        -:  467:#endif
        -:  468:
        -:  469:#ifndef MIN
        -:  470:# define MIN(a,b) (((a) < (b)) ? (a) : (b))
        -:  471:#endif
        -:  472:
        -:  473:#include "intprops.h"
        -:  474:
        -:  475:#ifndef SSIZE_MAX
        -:  476:# define SSIZE_MAX TYPE_MAXIMUM (ssize_t)
        -:  477:#endif
        -:  478:
        -:  479:#ifndef OFF_T_MIN
        -:  480:# define OFF_T_MIN TYPE_MINIMUM (off_t)
        -:  481:#endif
        -:  482:
        -:  483:#ifndef OFF_T_MAX
        -:  484:# define OFF_T_MAX TYPE_MAXIMUM (off_t)
        -:  485:#endif
        -:  486:
        -:  487:#ifndef UID_T_MAX
        -:  488:# define UID_T_MAX TYPE_MAXIMUM (uid_t)
        -:  489:#endif
        -:  490:
        -:  491:#ifndef GID_T_MAX
        -:  492:# define GID_T_MAX TYPE_MAXIMUM (gid_t)
        -:  493:#endif
        -:  494:
        -:  495:#ifndef PID_T_MAX
        -:  496:# define PID_T_MAX TYPE_MAXIMUM (pid_t)
        -:  497:#endif
        -:  498:
        -:  499:/* Use this to suppress gcc's `...may be used before initialized' warnings. */
        -:  500:#ifdef lint
        -:  501:# define IF_LINT(Code) Code
        -:  502:#else
        -:  503:# define IF_LINT(Code) /* empty */
        -:  504:#endif
        -:  505:
        -:  506:#ifndef __attribute__
        -:  507:# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
        -:  508:#  define __attribute__(x) /* empty */
        -:  509:# endif
        -:  510:#endif
        -:  511:
        -:  512:#ifndef ATTRIBUTE_NORETURN
        -:  513:# define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
        -:  514:#endif
        -:  515:
        -:  516:#ifndef ATTRIBUTE_UNUSED
        -:  517:# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  518:#endif
        -:  519:
        -:  520:#if defined strdupa
        -:  521:# define ASSIGN_STRDUPA(DEST, S)		\
        -:  522:  do { DEST = strdupa (S); } while (0)
        -:  523:#else
        -:  524:# define ASSIGN_STRDUPA(DEST, S)		\
        -:  525:  do						\
        -:  526:    {						\
        -:  527:      const char *s_ = (S);			\
        -:  528:      size_t len_ = strlen (s_) + 1;		\
        -:  529:      char *tmp_dest_ = alloca (len_);		\
        -:  530:      DEST = memcpy (tmp_dest_, s_, len_);	\
        -:  531:    }						\
        -:  532:  while (0)
        -:  533:#endif
        -:  534:
        -:  535:#ifndef EOVERFLOW
        -:  536:# define EOVERFLOW EINVAL
        -:  537:#endif
        -:  538:
        -:  539:#if ! HAVE_SYNC
        -:  540:# define sync() /* empty */
        -:  541:#endif
        -:  542:
        -:  543:/* Compute the greatest common divisor of U and V using Euclid's
        -:  544:   algorithm.  U and V must be nonzero.  */
        -:  545:
        -:  546:static inline size_t
        -:  547:gcd (size_t u, size_t v)
        -:  548:{
        -:  549:  do
        -:  550:    {
        -:  551:      size_t t = u % v;
        -:  552:      u = v;
        -:  553:      v = t;
        -:  554:    }
        -:  555:  while (v);
        -:  556:
        -:  557:  return u;
        -:  558:}
        -:  559:
        -:  560:/* Compute the least common multiple of U and V.  U and V must be
        -:  561:   nonzero.  There is no overflow checking, so callers should not
        -:  562:   specify outlandish sizes.  */
        -:  563:
        -:  564:static inline size_t
        -:  565:lcm (size_t u, size_t v)
        -:  566:{
        -:  567:  return u * (v / gcd (u, v));
        -:  568:}
        -:  569:
        -:  570:/* Return PTR, aligned upward to the next multiple of ALIGNMENT.
        -:  571:   ALIGNMENT must be nonzero.  The caller must arrange for ((char *)
        -:  572:   PTR) through ((char *) PTR + ALIGNMENT - 1) to be addressable
        -:  573:   locations.  */
        -:  574:
        -:  575:static inline void *
        -:  576:ptr_align (void const *ptr, size_t alignment)
        -:  577:{
        -:  578:  char const *p0 = ptr;
        -:  579:  char const *p1 = p0 + alignment - 1;
        -:  580:  return (void *) (p1 - (size_t) p1 % alignment);
        -:  581:}
        -:  582:
        -:  583:/* If 10*Accum + Digit_val is larger than the maximum value for Type,
        -:  584:   then don't update Accum and return false to indicate it would
        -:  585:   overflow.  Otherwise, set Accum to that new value and return true.
        -:  586:   Verify at compile-time that Type is Accum's type, and that Type is
        -:  587:   unsigned.  Accum must be an object, so that we can take its
        -:  588:   address.  Accum and Digit_val may be evaluated multiple times.
        -:  589:
        -:  590:   The "Added check" below is not strictly required, but it causes GCC
        -:  591:   to return a nonzero exit status instead of merely a warning
        -:  592:   diagnostic, and that is more useful.  */
        -:  593:
        -:  594:#define DECIMAL_DIGIT_ACCUMULATE(Accum, Digit_val, Type)		\
        -:  595:  (									\
        -:  596:   (void) (&(Accum) == (Type *) NULL),  /* The type matches.  */	\
        -:  597:   (void) verify_true (! TYPE_SIGNED (Type)), /* The type is unsigned.  */ \
        -:  598:   (void) verify_true (sizeof (Accum) == sizeof (Type)), /* Added check.  */ \
        -:  599:   (((Type) -1 / 10 < (Accum)						\
        -:  600:     || (Type) ((Accum) * 10 + (Digit_val)) < (Accum))			\
        -:  601:    ? false : (((Accum) = (Accum) * 10 + (Digit_val)), true))		\
        -:  602:  )
        -:  603:
        -:  604:static inline void
    #####:  605:emit_bug_reporting_address (void)
        -:  606:{
        -:  607:  /* TRANSLATORS: The placeholder indicates the bug-reporting address
        -:  608:     for this package.  Please add _another line_ saying
        -:  609:     "Report translation bugs to <...>\n" with the address for translation
        -:  610:     bugs (typically your translation team's web or email address).  */
    #####:  611:  printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
    #####:  612:}
